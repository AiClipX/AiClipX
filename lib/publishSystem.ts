// Platform-level publish system for cross-region sharing
import { t } from './i18n';

export type PublishRegion = 'KR' | 'EN' | 'CN';

export interface RegionTemplate {
  titlePattern: string;
  descriptionPattern: string;
  hashtags: string[];
  platformSpecific?: {
    youtube?: { titleSuffix?: string; descriptionPrefix?: string };
    tiktok?: { titleSuffix?: string; hashtagLimit?: number };
    instagram?: { titleSuffix?: string; hashtagLimit?: number };
  };
}

export interface PublishMetadata {
  title: string;
  description: string;
  hashtags: string[];
  region: PublishRegion;
  videoUrl: string;
  duration?: string;
  aspectRatio?: string;
}

// Region-specific templates and patterns
const REGION_TEMPLATES: Record<PublishRegion, RegionTemplate> = {
  KR: {
    titlePattern: '{title} | AI ìƒì„± ì˜ìƒ',
    descriptionPattern: 'AIë¡œ ìƒì„±ëœ ì°½ì˜ì ì¸ ì˜ìƒì…ë‹ˆë‹¤.\n\nì›ë³¸ í”„ë¡¬í”„íŠ¸: {prompt}\n\n#AIì˜ìƒ #ì°½ì‘ì½˜í…ì¸ ',
    hashtags: [
      '#AIì˜ìƒ', '#ì¸ê³µì§€ëŠ¥', '#ì°½ì‘ì½˜í…ì¸ ', '#ë””ì§€í„¸ì•„íŠ¸',
      '#ì˜ìƒì œì‘', '#í¬ë¦¬ì—ì´í‹°ë¸Œ', '#í…Œí¬ë†€ë¡œì§€', '#í˜ì‹ ',
      '#ë¯¸ë””ì–´ì•„íŠ¸', '#ìë™ìƒì„±', '#ì½˜í…ì¸ ì œì‘', '#ì˜ìƒí¸ì§‘',
      '#ë””ì§€í„¸í¬ë¦¬ì—ì´í„°', '#AIì•„íŠ¸', '#ì˜ìƒì½˜í…ì¸ ', '#ì°½ì˜ì ì‚¬ê³ ',
      '#ê¸°ìˆ í˜ì‹ ', '#ë¯¸ë˜ê¸°ìˆ ', '#ìŠ¤ë§ˆíŠ¸ì½˜í…ì¸ ', '#ë””ì§€í„¸ë¯¸ë””ì–´'
    ],
    platformSpecific: {
      youtube: { titleSuffix: ' - AI Generated', descriptionPrefix: 'ğŸ¤– AIë¡œ ì œì‘ëœ ì˜ìƒì…ë‹ˆë‹¤\n\n' },
      tiktok: { titleSuffix: ' #AIì˜ìƒ', hashtagLimit: 10 },
      instagram: { titleSuffix: ' ğŸ¤–', hashtagLimit: 15 }
    }
  },
  EN: {
    titlePattern: '{title} | AI Generated Video',
    descriptionPattern: 'Creative video generated using AI technology.\n\nOriginal prompt: {prompt}\n\n#AIVideo #CreativeContent',
    hashtags: [
      '#AIVideo', '#ArtificialIntelligence', '#CreativeContent', '#DigitalArt',
      '#VideoProduction', '#Creative', '#Technology', '#Innovation',
      '#MediaArt', '#AutoGenerated', '#ContentCreation', '#VideoEditing',
      '#DigitalCreator', '#AIArt', '#VideoContent', '#CreativeThinking',
      '#TechInnovation', '#FutureTech', '#SmartContent', '#DigitalMedia'
    ],
    platformSpecific: {
      youtube: { titleSuffix: ' - AI Generated', descriptionPrefix: 'ğŸ¤– AI-generated video content\n\n' },
      tiktok: { titleSuffix: ' #AIVideo', hashtagLimit: 10 },
      instagram: { titleSuffix: ' ğŸ¤–', hashtagLimit: 15 }
    }
  },
  CN: {
    titlePattern: '{title} | AIç”Ÿæˆè§†é¢‘',
    descriptionPattern: 'ä½¿ç”¨AIæŠ€æœ¯ç”Ÿæˆçš„åˆ›æ„è§†é¢‘ã€‚\n\nåŸå§‹æç¤º: {prompt}\n\n#AIè§†é¢‘ #åˆ›æ„å†…å®¹',
    hashtags: [
      '#AIè§†é¢‘', '#äººå·¥æ™ºèƒ½', '#åˆ›æ„å†…å®¹', '#æ•°å­—è‰ºæœ¯',
      '#è§†é¢‘åˆ¶ä½œ', '#åˆ›æ„', '#ç§‘æŠ€', '#åˆ›æ–°',
      '#åª’ä½“è‰ºæœ¯', '#è‡ªåŠ¨ç”Ÿæˆ', '#å†…å®¹åˆ›ä½œ', '#è§†é¢‘ç¼–è¾‘',
      '#æ•°å­—åˆ›ä½œè€…', '#AIè‰ºæœ¯', '#è§†é¢‘å†…å®¹', '#åˆ›æ„æ€ç»´',
      '#æŠ€æœ¯åˆ›æ–°', '#æœªæ¥ç§‘æŠ€', '#æ™ºèƒ½å†…å®¹', '#æ•°å­—åª’ä½“'
    ],
    platformSpecific: {
      youtube: { titleSuffix: ' - AIç”Ÿæˆ', descriptionPrefix: 'ğŸ¤– AIç”Ÿæˆçš„è§†é¢‘å†…å®¹\n\n' },
      tiktok: { titleSuffix: ' #AIè§†é¢‘', hashtagLimit: 10 },
      instagram: { titleSuffix: ' ğŸ¤–', hashtagLimit: 15 }
    }
  }
};

export class PublishManager {
  // Generate metadata for a specific region
  static generateMetadata(
    videoTitle: string,
    videoPrompt: string,
    videoUrl: string,
    region: PublishRegion,
    platform?: 'youtube' | 'tiktok' | 'instagram'
  ): PublishMetadata {
    const template = REGION_TEMPLATES[region];
    
    // Generate title with pattern
    let title = template.titlePattern
      .replace('{title}', videoTitle)
      .replace('{prompt}', videoPrompt);
    
    // Apply platform-specific title modifications
    if (platform && template.platformSpecific?.[platform]?.titleSuffix) {
      title += template.platformSpecific[platform].titleSuffix;
    }
    
    // Generate description with pattern
    let description = template.descriptionPattern
      .replace('{title}', videoTitle)
      .replace('{prompt}', videoPrompt);
    
    // Apply platform-specific description modifications
    if (platform && template.platformSpecific?.[platform]?.descriptionPrefix) {
      description = template.platformSpecific[platform].descriptionPrefix + description;
    }
    
    // Select hashtags based on platform limits
    let hashtags = [...template.hashtags];
    if (platform && template.platformSpecific?.[platform]?.hashtagLimit) {
      const limit = template.platformSpecific[platform].hashtagLimit!;
      hashtags = hashtags.slice(0, limit);
    }
    
    return {
      title: title.trim(),
      description: description.trim(),
      hashtags,
      region,
      videoUrl,
    };
  }
  
  // Get region display name
  static getRegionDisplayName(region: PublishRegion): string {
    const names = {
      KR: 'í•œêµ­ (Korean)',
      EN: 'English (Global)',
      CN: 'ä¸­æ–‡ (Chinese)'
    };
    return names[region];
  }
  
  // Get available regions
  static getAvailableRegions(): PublishRegion[] {
    return ['KR', 'EN', 'CN'];
  }
  
  // Validate video URL for publishing
  static async validateVideoUrl(videoUrl: string): Promise<{ valid: boolean; error?: string }> {
    try {
      const response = await fetch(videoUrl, { method: 'HEAD' });
      if (!response.ok) {
        return { 
          valid: false, 
          error: `Video not accessible (${response.status})` 
        };
      }
      return { valid: true };
    } catch (error: any) {
      return { 
        valid: false, 
        error: error.message || 'Network error accessing video' 
      };
    }
  }
  
  // Copy text to clipboard
  static async copyToClipboard(text: string): Promise<boolean> {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      return false;
    }
  }
  
  // Generate shareable link (if allowed by capabilities)
  static generateShareableLink(videoId: string, region?: PublishRegion): string {
    const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';
    let shareUrl = `${baseUrl}/dashboard/videos/${videoId}`;
    
    if (region) {
      shareUrl += `?region=${region}`;
    }
    
    return shareUrl;
  }
  
  // Download video file
  static async downloadVideo(
    videoUrl: string, 
    filename: string,
    onProgress?: (progress: number) => void
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await fetch(videoUrl);
      
      if (!response.ok) {
        return { 
          success: false, 
          error: `Download failed: ${response.status} ${response.statusText}` 
        };
      }
      
      const contentLength = response.headers.get('content-length');
      const total = contentLength ? parseInt(contentLength, 10) : 0;
      let loaded = 0;
      
      const reader = response.body?.getReader();
      if (!reader) {
        return { success: false, error: 'Unable to read video stream' };
      }
      
      const chunks: Uint8Array[] = [];
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        chunks.push(value);
        loaded += value.length;
        
        if (onProgress && total > 0) {
          onProgress((loaded / total) * 100);
        }
      }
      
      // Create blob and download
      const blob = new Blob(chunks, { type: 'video/mp4' });
      const url = window.URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      
      document.body.appendChild(a);
      a.click();
      
      // Cleanup
      setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }, 100);
      
      return { success: true };
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Download failed' 
      };
    }
  }
}